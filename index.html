<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aniran | جستجوگر انیمه هوشمند</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #0A0E17;
            --bg-secondary: #121826;
            --bg-tertiary: #1A2233;
            --text-primary: #EAEFFB;
            --text-secondary: #939CB0;
            --border-color: #2A334A;
            --accent-primary: #38BDF8; /* Sky Blue */
            --accent-secondary: #E879F9; /* Fuchsia */
            --font-family: 'Vazirmatn', sans-serif;
        }

        body.light {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F7F9FC;
            --bg-tertiary: #EDF1F7;
            --text-primary: #121826;
            --text-secondary: #5C677D;
            --border-color: #DDE3EE;
            --accent-primary: #0284C7; /* Darker Sky Blue */
            --accent-secondary: #C026D3; /* Darker Fuchsia */
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-family);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .bg-primary { background-color: var(--bg-primary); }
        .bg-secondary { background-color: var(--bg-secondary); }
        .bg-tertiary { background-color: var(--bg-tertiary); }
        .text-primary { color: var(--text-primary); }
        .text-secondary { color: var(--text-secondary); }
        .border-color { border-color: var(--border-color); }
        .accent-primary-text { color: var(--accent-primary); }
        .accent-primary-bg { background-color: var(--accent-primary); }
        .accent-secondary-text { color: var(--accent-secondary); }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

        .loader {
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .page-enter-active { animation: page-in 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        .page-exit-active { animation: page-out 0.4s cubic-bezier(0.7, 0, 0.84, 0) forwards; }
        @keyframes page-in { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes page-out { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(15px); } }

        .result-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .result-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 10px 30px -10px color-mix(in srgb, var(--accent-primary) 20%, transparent);
        }
        .result-card .card-img-container {
            position: relative;
            overflow: hidden;
        }
        .result-card:hover .card-img {
            transform: scale(1.05);
        }
        .card-img {
            transition: transform 0.4s ease;
        }

        @keyframes animate-gradient { to { background-position: 200% center; } }

        .animated-gradient-text {
            background-image: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-primary));
            background-size: 200% auto;
            color: transparent;
            background-clip: text;
            -webkit-background-clip: text;
            animation: animate-gradient 4s linear infinite;
        }
        
        .animated-gradient-svg .gradient-path {
            fill: url(#brand-gradient);
        }
        .animated-gradient-svg .gradient-stroke {
            stroke: url(#brand-gradient);
        }
        
        .gemini-button {
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .gemini-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 20px color-mix(in srgb, var(--accent-primary) 30%, transparent), 0 0 20px color-mix(in srgb, var(--accent-secondary) 30%, transparent);
        }
        .gemini-button:disabled {
            background: var(--bg-tertiary);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .chat-bubble {
            max-width: 75%;
            padding: 10px 15px;
            border-radius: 20px;
        }
        .chat-bubble-user {
            background-color: var(--accent-primary);
            color: white;
            border-bottom-right-radius: 5px;
            align-self: flex-end;
        }
        .chat-bubble-bot {
            background-color: var(--bg-tertiary);
            border-bottom-left-radius: 5px;
            align-self: flex-start;
        }
        
        .video-thumbnail-list {
            display: flex;
            overflow-x: auto;
            gap: 1rem;
            padding-bottom: 1rem;
        }
        .video-thumbnail {
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }
        .video-thumbnail.active {
            border-color: var(--accent-primary);
        }

    </style>
</head>
<body class="bg-primary text-primary">

    <header class="sticky top-0 z-30 w-full p-4 bg-primary/80 backdrop-blur-lg border-b border-color">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-1">
                <svg class="h-14 w-auto animated-gradient-svg" viewBox="0 0 80 60" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="brand-gradient" x1="-20%" y1="0%" x2="120%" y2="0%">
                             <stop offset="0%" stop-color="var(--accent-primary)"/>
                             <stop offset="50%" stop-color="var(--accent-secondary)"/>
                             <stop offset="100%" stop-color="var(--accent-primary)"/>
                             <animate attributeName="x1" from="-100%" to="100%" dur="4s" repeatCount="indefinite" />
                             <animate attributeName="x2" from="0%" to="200%" dur="4s" repeatCount="indefinite" />
                        </linearGradient>
                    </defs>
                    <g>
                        <path class="gradient-path" d="M54,55 L42,12 C41.5,10.6 39.5,10.6 39,12 L27,55 L18,55 L35,8 L46,8 L63,55 Z" />
                        <g transform="translate(4,0)">
                          <circle class="gradient-stroke" cx="56" cy="34" r="14" fill="none" stroke-width="4"/>
                          <circle class="gradient-path" cx="56" cy="34" r="6" />
                        </g>
                        <path class="gradient-path" d="M62,13 L68,3 L74,13 Z" />
                    </g>
                </svg>
                <h1 class="animated-gradient-text text-4xl font-extrabold transform translate-y-2">Aniran</h1>
            </div>
            
            <div class="relative">
                <button id="menu-toggle-btn" class="p-2 rounded-full hover:bg-secondary transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                    </svg>
                </button>
                <div id="main-menu" class="hidden absolute left-0 mt-2 w-56 bg-secondary rounded-lg shadow-lg border border-color p-2 z-40">
                    <div class="p-2 space-y-1">
                        <button data-tab="search" class="tab-button w-full flex items-center gap-3 text-sm px-3 py-2 rounded-md hover:bg-tertiary transition-colors accent-primary-text">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" /></svg>
                            <span>جستجو</span>
                        </button>
                        <button data-tab="airing" class="tab-button w-full flex items-center gap-3 text-sm px-3 py-2 rounded-md hover:bg-tertiary transition-colors text-secondary">
                           <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                            <span>در حال پخش</span>
                        </button>
                        <button data-tab="top" class="tab-button w-full flex items-center gap-3 text-sm px-3 py-2 rounded-md hover:bg-tertiary transition-colors text-secondary">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>
                            <span>برترین‌های MAL</span>
                        </button>
                        <hr class="border-color !my-2">
                        <button id="api-key-btn" class="w-full flex items-center gap-3 text-sm px-3 py-2 rounded-md hover:bg-tertiary transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 8a6 6 0 01-7.743 5.743L10 14l-1 1-1 1H6v2H2v-4l4.257-4.257A6 6 0 1118 8zm-6-4a1 1 0 100 2 1 1 0 000-2z" clip-rule="evenodd" /></svg>
                            <span id="api-key-btn-text">تنظیم API</span>
                        </button>
                        <div class="flex justify-between items-center px-3 py-2">
                            <span class="text-sm flex items-center gap-3">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" /></svg>
                                حالت شب/روز
                            </span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="theme-switch" class="sr-only peer">
                                <div class="w-11 h-6 bg-tertiary rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-accent-primary"></div>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4 md:p-6">
        <div id="search-page">
            <div class="text-center my-8 md:my-16">
                <h2 class="text-4xl md:text-6xl font-extrabold animated-gradient-text mb-4">دنیای انیمه را کاوش کنید</h2>
                <p class="text-lg text-secondary max-w-2xl mx-auto">هر انیمه‌ای که به دنبالش هستید را پیدا کنید، از آثار کلاسیک تا جدیدترین عناوین در حال پخش.</p>
            </div>
            <form id="search-form" class="max-w-2xl mx-auto">
                <div class="relative">
                    <input type="search" id="search-input" class="bg-secondary w-full p-4 pr-12 text-lg rounded-full border-2 border-color focus:border-accent-primary focus:outline-none focus:ring-2 focus:ring-accent-primary/50 transition-all placeholder-text-secondary" placeholder="نام انیمه به فارسی یا انگلیسی..." required>
                    <svg class="w-6 h-6 absolute top-1/2 -translate-y-1/2 right-4 text-secondary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                </div>
            </form>
            <div class="text-center mt-6">
                <button id="smart-suggest-btn" class="gemini-button text-white font-bold py-3 px-6 rounded-full" disabled>
                    ✨ پیشنهاد مفهومی
                </button>
            </div>
        </div>

        <div id="list-page" class="hidden">
            <h2 id="list-title" class="text-3xl font-bold text-center my-8"></h2>
            <div id="season-nav" class="hidden justify-center items-center gap-4 my-6">
                <button id="prev-season-btn" class="accent-primary-bg text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity">&lt; فصل قبل</button>
                <span id="season-display" class="font-bold text-xl"></span>
                <button id="next-season-btn" class="accent-primary-bg text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 transition-opacity">فصل بعد &gt;</button>
            </div>
        </div>
        
        <h3 id="smart-results-title" class="text-2xl font-bold text-center my-8 hidden"></h3>

        <div id="loader" class="hidden justify-center items-center my-16 flex-col"><div class="loader"></div></div>
        <div id="message" class="text-center text-secondary my-8 text-lg"></div>
        <div id="results-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6 mt-12"></div>
        <div id="show-more-container" class="text-center mt-8"></div>
    </main>

    <section id="details-page" class="hidden"></section>
    
    <div id="modal-container"></div>

    <script type="module">
        const JIKAN_API_BASE = "https://api.jikan.moe/v4";

        const DOMElements = {
            mainPage: document.querySelector('main'),
            searchPage: document.getElementById('search-page'),
            listPage: document.getElementById('list-page'),
            listTitle: document.getElementById('list-title'),
            detailsPage: document.getElementById('details-page'),
            searchForm: document.getElementById('search-form'),
            searchInput: document.getElementById('search-input'),
            resultsContainer: document.getElementById('results-container'),
            showMoreContainer: document.getElementById('show-more-container'),
            smartResultsTitle: document.getElementById('smart-results-title'),
            messageDiv: document.getElementById('message'),
            loader: document.getElementById('loader'),
            themeSwitch: document.getElementById('theme-switch'),
            modalContainer: document.getElementById('modal-container'),
            seasonNav: document.getElementById('season-nav'),
            seasonDisplay: document.getElementById('season-display'),
            prevSeasonBtn: document.getElementById('prev-season-btn'),
            nextSeasonBtn: document.getElementById('next-season-btn'),
            smartSuggestBtn: document.getElementById('smart-suggest-btn'),
            apiKeyBtn: document.getElementById('api-key-btn'),
            apiKeyBtnText: document.getElementById('api-key-btn-text'),
            menuToggleBtn: document.getElementById('menu-toggle-btn'),
            mainMenu: document.getElementById('main-menu'),
        };

        let isTransitioning = false;
        const translationCache = new Map();
        let navigationHistory = [];
        let currentSeasonState = { year: 0, season: '' };
        let searchDebounceTimeout;
        let latestSearchQuery = '';
        let currentAnimeData = null;
        let geminiApiKey = null;
        let currentPage = 1;
        let currentListType = '';

        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- OFFLINE TRANSLATOR ---
        const offlineTranslator = {
            dictionary: {
                // Genres
                "Action": "اکشن", "Adventure": "ماجراجویی", "Comedy": "کمدی", "Drama": "درام", "Fantasy": "فانتزی", "Horror": "ترسناک", "Mystery": "رازآلود", "Romance": "عاشقانه", "Sci-Fi": "علمی تخیلی", "Slice of Life": "برشی از زندگی", "Sports": "ورزشی", "Supernatural": "ماوراء طبیعی", "Suspense": "دلهره آور", "Award Winning": "برنده جایزه",
                // Themes
                "Gourmet": "خوش خوراک", "Ecchi": "ایچی", "Erotica": "اروتیک", "Hentai": "هنتای", "Adult Cast": "بازیگران بزرگسال", "Anthropomorphic": "انسان‌انگاری", "CGDCT": "دختران ناز کارهای ناز انجام می‌دهند", "Childcare": "مراقبت از کودک", "Combat Sports": "ورزش‌های رزمی", "Crossdressing": "مبدل‌پوشی", "Delinquents": "بزهکاران", "Detective": "کارآگاهی", "Educational": "آموزشی", "Gag Humor": "طنز بی‌معنی", "Gore": "خونین", "Harem": "حرمسرا", "High Stakes Game": "بازی پرخطر", "Historical": "تاریخی", "Idols (Female)": "آیدل (زن)", "Idols (Male)": "آیدل (مرد)", "Isekai": "ایسکای", "Iyashikei": "آرامش‌بخش", "Love Polygon": "چندضلعی عشقی", "Magical Sex-Shift": "تغییر جنسیت جادویی", "Mahou Shoujo": "دختر جادویی", "Martial Arts": "هنرهای رزمی", "Mecha": "مکا", "Medical": "پزشکی", "Military": "نظامی", "Music": "موسیقی", "Mythology": "اساطیری", "Organized Crime": "جرایم سازمان‌یافته", "Otaku Culture": "فرهنگ اوتاکو", "Parody": "نقیضه", "Performing Arts": "هنرهای نمایشی", "Pets": "حیوانات خانگی", "Psychological": "روانشناختی", "Racing": "مسابقه‌ای", "Reincarnation": "تناسخ", "Reverse Harem": "حرمسرای معکوس", "Romantic Subtext": "معنای ضمنی عاشقانه", "Samurai": "سامورایی", "School": "مدرسه‌ای", "Showbiz": "شوبیز", "Space": "فضایی", "Strategy Game": "بازی استراتژیک", "Super Power": "قدرت فوق‌العاده", "Survival": "بقا", "Team Sports": "ورزش تیمی", "Time Travel": "سفر در زمان", "Vampire": "خون‌آشام", "Video Game": "بازی ویدیویی", "Visual Arts": "هنرهای تجسمی", "Workplace": "محیط کار", "Avant Garde": "آوانگارد",
                // Demographics
                "Josei": "جوسِی", "Kids": "کودکان", "Seinen": "سینن", "Shoujo": "شوجو", "Shounen": "شونن", "Boys Love": "عشق پسران", "Girls Love": "عشق دختران",
                // Status
                "Currently Airing": "در حال پخش", "Finished Airing": "پخش تمام شده", "Not yet aired": "هنوز پخش نشده",
                // Types
                "TV": "تلویزیونی", "Movie": "سینمایی", "OVA": "او وی ای", "Special": "ویژه", "ONA": "اونا",
                // Seasons
                "winter": "زمستان", "spring": "بهار", "summer": "تابستان", "fall": "پاییز",
                // Ratings
                "G - All Ages": "G - برای تمام سنین", "PG - Children": "PG - برای کودکان", "PG-13 - Teens 13 or older": "PG-13 - برای نوجوانان ۱۳ سال به بالا", "R - 17+ (violence & profanity)": "R - 17+ (خشونت و ناسزا)", "R+ - Mild Nudity": "R+ - برهنگی خفیف", "Rx - Hentai": "Rx - هنتای",
                // Adaptation Sources
                "Manga": "مانگا", "Original": "اورجینال", "Light novel": "لایت ناول", "Game": "بازی", "Visual novel": "ویژوال ناول", "Web manga": "وب مانگا", "Novel": "رمان", "4-koma manga": "مانگا ۴ پنلی", "Book": "کتاب", "Picture book": "کتاب مصور", "Card game": "بازی کارتی", "Web novel": "وب ناول", "Other": "غیره", "Music": "موسیقی", "Radio": "رادیو",
                // Common Titles & Synopses for demonstration
                "No synopsis available.": "خلاصه داستان موجود نیست.",
                "Death Note": "دفترچه مرگ", "A brilliant high school student who discovers a supernatural notebook that allows him to kill anyone by writing their name in it.": "یک دانش‌آموز دبیرستانی نابغه یک دفترچه فراطبیعی پیدا می‌کند که به او اجازه می‌دهد با نوشتن نام هر کسی در آن، او را بکشد.",
                "Attack on Titan": "حمله به تایتان", "After his hometown is destroyed and his mother is killed, young Eren Jaeger vows to cleanse the earth of the giant humanoid Titans that have brought humanity to the brink of extinction.": "پس از نابودی زادگاهش و کشته شدن مادرش، ارن یگر جوان قسم می‌خورد که زمین را از تایتان‌های غول‌پیکر انسان‌نما که بشریت را تا مرز انقراض کشانده‌اند، پاک کند.",
                "Fullmetal Alchemist: Brotherhood": "کیمیاگر تمام‌فلزی: برادری", "Two brothers search for the Philosopher's Stone after an attempt to revive their deceased mother goes awry and leaves them in damaged physical forms.": "دو برادر پس از اینکه تلاش برای احیای مادر مرحومشان با شکست مواجه می‌شود و آن‌ها را با بدن‌های آسیب‌دیده رها می‌کند، به دنبال سنگ فلاسفه می‌گردند.",
                "Naruto": "ناروتو", "Naruto Uzumaki, a mischievous adolescent ninja, struggles as he searches for recognition and dreams of becoming the Hokage, the village's leader and strongest ninja.": "ناروتو اوزوماکی، یک نینجای نوجوان بازیگوش، در حالی که به دنبال به رسمیت شناخته شدن است و رویای هوکاگه شدن، یعنی رهبر و قوی‌ترین نینجای دهکده، را در سر می‌پروراند، تلاش می‌کند.",
                "One Piece": "وان پیس", "Follows the adventures of Monkey D. Luffy and his pirate crew in order to find the greatest treasure ever left by the legendary Pirate, Gold Roger. The famous mystery treasure named \"One Piece\".": "ماجراهای مانکی دی. لوفی و خدمه دزدان دریایی او را دنبال می‌کند تا بزرگترین گنجی را که توسط دزد دریایی افسانه‌ای، گل دی. راجر، به جا مانده است، پیدا کنند. گنج اسرارآمیز معروفی به نام «وان پیس».",
                "Owarimonogatari": "اواری‌مونوگاتاری", "Apparitions, oddities, and gods continue to manifest around Koyomi Araragi and his close-knit group of friends: Tsubasa Hanekawa, the group's modest genius; Shinobu Oshino, the resident doughnut-loving vampire; athletic deviant Suruga Kanbaru; bite-happy spirit Mayoi Hachikuji; Koyomi's cutesy admirer Nadeko Sengoku; and Hitagi Senjougahara, the standoffish yet caring girlfriend. As Koyomi tries to balance his relationships with each of them, he is forced to confront the darkness that surrounds them. With graduation looming over him, Koyomi must quickly decide what he will do and who he will save.": "اشباح، شگفتی‌ها و خدایان همچنان در اطراف کویومی آراراگی و گروه دوستان صمیمی‌اش ظاهر می‌شوند: سوباسا هانکاوا، نابغه متواضع گروه؛ شینوبو اوشینو، خون‌آشام عاشق دونات؛ سوروگا کانبارو، ورزشکار منحرف؛ مایوی هاچیکوجی، روح سرگردان؛ نادکو سنگوکو، تحسین‌کننده بامزه کویومی؛ و هیتاگی سنجوگاهارا، دوست‌دختر سرد اما مهربان او. در حالی که کویومی تلاش می‌کند تا روابط خود را با هر یک از آنها متعادل کند، مجبور می‌شود با تاریکی‌ای که آنها را احاطه کرده است، روبرو شود. با نزدیک شدن به فارغ‌التحصیلی، کویومی باید به سرعت تصمیم بگیرد که چه کاری انجام خواهد داد و چه کسی را نجات خواهد داد."
            },
            translate(text) {
                if (!text) return text;
                const trimmedText = text.trim();
                // First, check for an exact match (good for ratings and specific phrases)
                if (this.dictionary[trimmedText]) {
                    return this.dictionary[trimmedText];
                }
                // If no exact match, try cleaning the text (good for titles with "(TV)" etc.)
                const cleanText = trimmedText.replace(/\s*\([^)]*\)$/, '').replace(/\[Written by MAL Rewrite\]/g, '').trim();
                return this.dictionary[cleanText] || text;
            }
        };

        const APIManager = {
            async fetchJikan(endpoint) {
                try {
                    const response = await fetch(`${JIKAN_API_BASE}/${endpoint}`);
                    await delay(350); // Rate limiting
                    if (!response.ok) {
                        // START: Added specific error handling for 429 status
                        if (response.status === 429) {
                            throw new Error(`تعداد درخواست‌ها از سرور انیمه بیش از حد مجاز است. لطفاً چند لحظه صبر کرده و دوباره امتحان کنید.`);
                        }
                        // END: Added specific error handling for 429 status
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`خطا در ارتباط با سرور انیمه (${response.status}): ${errorData.message || response.statusText}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error("Jikan API fetch error:", error);
                    throw new Error(error.message || "خطا در دریافت اطلاعات از سرور انیمه.");
                }
            },
            
            async callGemini(prompt, isJson = false) {
                if (!geminiApiKey) throw new Error("کلید API جمنای تنظیم نشده است. لطفاً از منوی تنظیمات، کلید خود را وارد کنید.");
                try {
                    const payload = { 
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        ...(isJson && { generationConfig: { responseMimeType: "application/json" } })
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
                    const response = await fetch(apiUrl, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload) 
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        if (response.status === 400) throw new Error(`درخواست نامعتبر. ممکن است کلید API مشکل داشته باشد. (${errorData?.error?.message || ''})`);
                        if (response.status === 401 || response.status === 403) throw new Error(`خطای احراز هویت. کلید API نامعتبر است یا دسترسی لازم را ندارد.`);
                        if (response.status === 429) throw new Error(`تعداد درخواست‌ها از حد مجاز فراتر رفته است (429).`);
                        throw new Error(`خطا در ارتباط با سرور هوش مصنوعی: (${response.status})`);
                    }
                    
                    const result = await response.json();
                    const part = result.candidates?.[0]?.content?.parts?.[0];
                    if (part?.text) {
                        try {
                            return isJson ? JSON.parse(part.text) : part.text;
                        } catch (e) {
                            console.error("Failed to parse Gemini JSON response:", e, part.text);
                            throw new Error("پاسخ دریافت شده از هوش مصنوعی در فرمت مورد انتظار (JSON) نبود.");
                        }
                    } else {
                        if (result.candidates?.[0]?.finishReason === 'SAFETY') throw new Error("پاسخ به دلیل محدودیت‌های ایمنی مسدود شد.");
                        throw new Error("پاسخ غیرمنتظره یا خالی از سرویس هوش مصنوعی دریافت شد.");
                    }
                } catch (error) {
                    console.error("Gemini API Call Error:", error);
                    throw error;
                }
            },

            async validateApiKey(key) {
                if (!key) return false;
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                    return response.ok && Array.isArray((await response.json()).models);
                } catch (error) {
                    console.error("API Key validation failed:", error);
                    return false;
                }
            },

            async batchTranslate(texts) {
                const uniqueTexts = [...new Set(texts.filter(t => t && !translationCache.has(t)))];
                if (uniqueTexts.length === 0) return;

                const prompt = `Translate the following list of English phrases to Persian. Return a JSON object where keys are the original English phrases and values are their Persian translations. Provide ONLY the JSON object.\nPhrases: ${JSON.stringify(uniqueTexts)}`;
                
                try {
                    const translatedJson = await this.callGemini(prompt, true);
                    for (const [key, value] of Object.entries(translatedJson)) {
                        const cleanedValue = typeof value === 'string' ? value.replace(/["'«»]/g, "").trim() : value;
                        translationCache.set(key, cleanedValue);
                    }
                } catch (error) {
                    console.warn("Gemini batch translation failed, will use offline for untranslated items.", error.message);
                }
            },
            
            async translateToEnglish(text) {
                if (!text) return text;
                if (!geminiApiKey) {
                    throw new Error("جستجوی فارسی نیازمند تنظیم کلید API جمنای است. لطفاً از منو، کلید خود را وارد کنید.");
                }
                
                const cacheKey = `en_${text}`;
                if (translationCache.has(cacheKey)) return translationCache.get(cacheKey);

                try {
                    const prompt = `Translate the following Persian phrase to its most common English title for anime searching. Respond with only the English translation. Phrase: "${text}"`;
                    const translation = await this.callGemini(prompt);
                    const cleanedTranslation = translation.replace(/["'«»]/g, "").trim();
                    if (cleanedTranslation) translationCache.set(cacheKey, cleanedTranslation);
                    return cleanedTranslation || text;
                } catch (error) {
                    console.error("Translation Error (to English):", error);
                    throw new Error(`ترجمه عبارت "${text}" با خطا مواجه شد. لطفاً اتصال اینترنت یا کلید API خود را بررسی کنید.`);
                }
            }
        };

        const ModalManager = {
            create(id, content, options = {}) {
                this.closeAll();
                const modalWrapper = document.createElement('div');
                modalWrapper.id = id;
                modalWrapper.className = "fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4";
                const modalContent = document.createElement('div');
                modalContent.className = `bg-secondary rounded-lg shadow-xl w-full flex flex-col ${options.maxWidth || 'max-w-xl'} ${options.maxHeight || 'max-h-[90vh]'}`;
                modalContent.innerHTML = content;
                modalWrapper.appendChild(modalContent);
                DOMElements.modalContainer.appendChild(modalWrapper);
                return modalContent;
            },
            close(id) {
                const modal = document.getElementById(id);
                if (modal) modal.remove();
            },
            closeAll() { DOMElements.modalContainer.innerHTML = ''; },
            showNotification(message, type = 'info') {
                this.closeAll();
                const colors = {
                    info: 'accent-primary-bg',
                    success: 'bg-green-500',
                    error: 'bg-red-500'
                };
                const modalWrapper = document.createElement('div');
                modalWrapper.id = 'notification-modal';
                modalWrapper.className = "fixed top-5 right-5 z-50 transition-transform duration-300 transform translate-x-full";
                modalWrapper.innerHTML = `<div class="p-4 text-white ${colors[type] || colors.info} rounded-lg shadow-lg"><p>${message}</p></div>`;
                DOMElements.modalContainer.appendChild(modalWrapper);
                
                setTimeout(() => modalWrapper.classList.remove('translate-x-full'), 10);

                setTimeout(() => {
                    modalWrapper.classList.add('translate-x-full');
                    setTimeout(() => this.close('notification-modal'), 300);
                }, 3000);
            }
        };

        const UIManager = {
            showLoader(show) { DOMElements.loader.style.display = show ? 'flex' : 'none'; },
            showMessage(text, isError = false) { 
                DOMElements.messageDiv.textContent = text;
                DOMElements.messageDiv.classList.toggle('text-red-400', isError);
                DOMElements.messageDiv.classList.toggle('text-secondary', !isError);
            },
            displayResults(results, title = '', options = {}) {
                if (!options.append) {
                    DOMElements.resultsContainer.innerHTML = '';
                    DOMElements.showMoreContainer.innerHTML = '';
                }
                
                DOMElements.smartResultsTitle.classList.toggle('hidden', !title);
                DOMElements.smartResultsTitle.textContent = title;

                if (!results || results.length === 0) { 
                    if (!options.append) this.showMessage("هیچ نتیجه‌ای یافت نشد.");
                    return; 
                }
                
                results.forEach(item => {
                    const node = item.node || item;
                    const card = document.createElement('div');
                    card.className = 'result-card bg-tertiary rounded-lg overflow-hidden shadow-lg cursor-pointer group';
                    card.dataset.id = node.mal_id;
                    card.innerHTML = `
                        <div class="card-img-container rounded-lg">
                            <img src="${node.images.webp.large_image_url || 'https://placehold.co/400x600/1A2233/939CB0?text=بدون+عکس'}" alt="${node.title}" class="card-img w-full h-auto aspect-[2/3] object-cover" onerror="this.onerror=null;this.src='https://placehold.co/400x600/1A2233/939CB0?text=بدون+عکس';">
                            <div class="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-black/80 to-transparent">
                                <h3 class="font-bold text-sm text-white truncate group-hover:accent-primary-text transition-colors" title="${node.title}">${node.title}</h3>
                                <div class="text-xs text-gray-300 flex justify-between items-center mt-1">
                                    <span>${node.type || ''}</span>
                                    <span class="flex items-center gap-1">
                                        <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>
                                        ${node.score || 'N/A'}
                                    </span>
                                </div>
                            </div>
                        </div>`;
                    DOMElements.resultsContainer.appendChild(card);
                });

                if (options.showMoreCallback) {
                    DOMElements.showMoreContainer.innerHTML = '';
                    const showMoreBtn = document.createElement('button');
                    showMoreBtn.id = 'show-more-btn';
                    showMoreBtn.className = 'gemini-button text-white font-bold py-3 px-6 rounded-full';
                    showMoreBtn.innerHTML = 'بارگیری بیشتر';
                    DOMElements.showMoreContainer.appendChild(showMoreBtn);
                }
            },
            showMainPage() {
                if (isTransitioning) return; isTransitioning = true;
                DOMElements.detailsPage.classList.add('page-exit-active');
                ModalManager.closeAll();
                setTimeout(() => {
                    DOMElements.detailsPage.classList.add('hidden'); DOMElements.detailsPage.classList.remove('page-exit-active');
                    DOMElements.mainPage.classList.remove('hidden'); DOMElements.mainPage.classList.add('page-enter-active');
                    DOMElements.detailsPage.innerHTML = ''; isTransitioning = false;
                }, 400);
            },
            async showDetailsPage(id) {
                if (isTransitioning) return; isTransitioning = true;
                DOMElements.mainPage.classList.add('hidden');
                DOMElements.detailsPage.innerHTML = `<div class="flex justify-center items-center min-h-screen"><div class="loader"></div></div>`;
                DOMElements.detailsPage.classList.remove('hidden'); DOMElements.detailsPage.classList.add('page-enter-active');
                window.scrollTo(0, 0);
                
                try {
                    const result = await APIManager.fetchJikan(`anime/${id}/full`);
                    currentAnimeData = result.data;
                    const data = currentAnimeData;
                    
                    const allGenres = [...data.genres, ...data.themes, ...data.demographics];

                    DOMElements.detailsPage.innerHTML = `
                        <div class="relative">
                            <div class="absolute top-0 left-0 w-full h-[40vh] md:h-[50vh] overflow-hidden">
                                <div class="absolute inset-0 bg-gradient-to-t from-bg-primary to-bg-primary/20 z-10"></div>
                                <img src="${data.images.webp.large_image_url || ''}" class="w-full h-full object-cover object-center opacity-30" alt="Backdrop">
                            </div>
                            <button id="back-button" class="fixed top-6 right-6 bg-secondary/70 backdrop-blur-sm hover:bg-tertiary font-bold p-3 rounded-full z-20 shadow-lg transition-colors">&larr;</button>
                            <div class="relative z-10 container mx-auto p-4 md:p-8 max-w-7xl pt-[20vh] md:pt-[25vh]">
                                <div class="flex flex-col md:flex-row md:gap-8 lg:gap-12">
                                    <div class="w-full md:w-1/3 lg:w-1/4 flex-shrink-0 text-center">
                                        <img src="${data.images.webp.large_image_url || 'https://placehold.co/400x600/1A2233/939CB0?text=بدون+عکس'}" alt="Poster" class="w-full max-w-[250px] mx-auto rounded-xl shadow-2xl shadow-black/50 border-4 border-tertiary">
                                        <div class="mt-4">
                                            <h2 id="persian-title" class="text-2xl lg:text-3xl font-black animated-gradient-text">${data.title_english || data.title}</h2>
                                            <p class="text-sm text-secondary mt-1">${data.title}</p>
                                        </div>
                                        <div id="details-box" class="bg-tertiary p-4 rounded-lg text-sm mt-6 text-right"></div>
                                    </div>
                                    <div class="w-full md:w-2/3 lg:w-3/4 mt-8 md:mt-0">
                                        <div id="latest-episode-section" class="mb-6"></div>
                                        <div class="flex flex-wrap gap-4 mb-6">
                                            <div class="flex items-center gap-2 bg-tertiary p-2 px-4 rounded-full"><span class="font-bold text-yellow-400 text-xl">${data.score || 'N/A'}</span><span class="text-xs text-secondary">امتیاز</span></div>
                                            <div class="flex items-center gap-2 bg-tertiary p-2 px-4 rounded-full"><span class="font-bold text-xl">#${data.rank?.toLocaleString() || 'N/A'}</span><span class="text-xs text-secondary">رتبه</span></div>
                                            <div class="flex items-center gap-2 bg-tertiary p-2 px-4 rounded-full"><span class="font-bold text-xl">${data.members?.toLocaleString() || 'N/A'}</span><span class="text-xs text-secondary">عضو</span></div>
                                        </div>
                                        <div class="mb-6"><h3 class="font-bold text-xl mb-3">ژانرها</h3><div id="genre-container" class="flex flex-wrap gap-2">${allGenres.map(g => `<span class="bg-tertiary text-sm font-semibold px-3 py-1 rounded-full">${g.name}</span>`).join('')}</div></div>
                                        <div class="mb-6">
                                            <div class="flex justify-between items-center mb-3">
                                                <h3 class="font-bold text-xl">خلاصه داستان</h3>
                                                <div class="flex gap-2">
                                                    <button id="smart-analysis-btn" class="gemini-button text-white text-xs font-bold py-2 px-3 rounded-full" disabled>✨ تحلیل هوشمند</button>
                                                    <button id="find-similar-btn" class="bg-tertiary border border-color text-xs font-bold py-2 px-3 rounded-full hover:bg-secondary" disabled>✨ یافتن مشابه</button>
                                                </div>
                                            </div>
                                            <p id="synopsis-text" class="text-secondary text-base leading-relaxed whitespace-pre-wrap">${data.synopsis || 'خلاصه داستان موجود نیست.'}</p>
                                        </div>
                                        <div id="subtitles-section" class="mb-6"></div>
                                        <div id="relations-section" class="mb-6"></div>
                                        <div id="videos-section" class="mb-6"></div>
                                        <div id="characters-section" class="mb-6"></div>
                                        <div id="recommendations-section"></div>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    
                    isTransitioning = false;
                    
                    this.renderDetailsBox(data);
                    await this.triggerTranslations(data);

                    if (data.status === 'Currently Airing') this.renderLatestEpisode(id);
                    this.renderSubtitlesSection(data);
                    this.renderRelations(data.relations);
                    this.renderVideos(id, data.trailer);
                    
                    // START: Staggered API calls to avoid rate limiting
                    await delay(400);
                    await this.renderCharacters(id);

                    await delay(400);
                    await this.renderRecommendations(id);
                    // END: Staggered API calls

                    App.updateAiFeatureVisibility();

                    // START: Added translation check logic
                    setTimeout(async () => {
                        // اطمینان از اینکه کاربر هنوز در صفحه جزئیات است و داده‌ها مربوط به همین انیمه است
                        if (document.getElementById('details-page').classList.contains('hidden') || !currentAnimeData || currentAnimeData.mal_id !== parseInt(id)) {
                            return; // کاربر صفحه را ترک کرده، کاری انجام نده
                        }

                        const titleEl = document.getElementById('persian-title');
                        const synopsisEl = document.getElementById('synopsis-text');

                        // اگر عناصر وجود نداشتند، خارج شو
                        if (!titleEl || !synopsisEl) return;

                        const originalTitle = currentAnimeData.title_english || currentAnimeData.title;
                        const originalSynopsis = currentAnimeData.synopsis || "No synopsis available.";
                        
                        const textsToRetry = [];

                        // بررسی اینکه آیا متن عنوان هنوز به زبان اصلی است یا خیر
                        if (titleEl.textContent.trim() === originalTitle.trim()) {
                           textsToRetry.push(originalTitle);
                        }

                        // بررسی اینکه آیا متن خلاصه داستان هنوز به زبان اصلی است یا خیر
                        if (synopsisEl.textContent.trim() === originalSynopsis.trim()) {
                           textsToRetry.push(originalSynopsis);
                        }

                        // اگر متنی برای ترجمه مجدد وجود داشت و کلید API تنظیم شده بود
                        if (textsToRetry.length > 0 && geminiApiKey) {
                            try {
                                await APIManager.batchTranslate(textsToRetry);

                                // به‌روزرسانی متن‌ها از کش ترجمه
                                if (translationCache.has(originalTitle)) {
                                    titleEl.textContent = translationCache.get(originalTitle);
                                }
                                if (translationCache.has(originalSynopsis)) {
                                    synopsisEl.textContent = translationCache.get(originalSynopsis);
                                }
                            } catch (error) {
                                console.error("Error during re-translation check:", error);
                            }
                        }
                    }, 10000); // تاخیر ۱۰ ثانیه‌ای
                    // END: Added translation check logic

                } catch (error) {
                    DOMElements.detailsPage.innerHTML = `<button id="back-button" class="fixed top-6 right-6 bg-secondary/70 hover:bg-tertiary font-bold p-3 rounded-full z-20 shadow-lg">&larr;</button><div class="flex justify-center items-center min-h-screen"><p class="p-8 text-center text-red-400 text-xl font-bold">${error.message}</p></div>`;
                    isTransitioning = false;
                }
            },
            async triggerTranslations(data) {
                const elementsToTranslate = {
                    '#persian-title': data.title_english || data.title,
                    '#synopsis-text': data.synopsis || "No synopsis available.",
                    '#rating-value': data.rating || '',
                    '#source-value': data.source || '',
                };
                const genreSpans = document.querySelectorAll('#genre-container span');

                // --- OFFLINE-FIRST TRANSLATION ---
                for (const [selector, originalText] of Object.entries(elementsToTranslate)) {
                    const el = document.querySelector(selector);
                    if (el && originalText) {
                        el.textContent = offlineTranslator.translate(originalText);
                    }
                }
                genreSpans.forEach(span => {
                    span.textContent = offlineTranslator.translate(span.textContent);
                });

                // --- API ENHANCEMENT (if available) ---
                if (geminiApiKey) {
                    const textsToBatch = [];
                    // Only add texts to batch if they were NOT found in the offline dictionary
                    for (const originalText of Object.values(elementsToTranslate)) {
                        if (originalText && offlineTranslator.translate(originalText) === originalText) {
                            textsToBatch.push(originalText);
                        }
                    }
                    
                    if (textsToBatch.length > 0) {
                       await APIManager.batchTranslate(textsToBatch);
                    }

                    // Update from cache (which now contains API results)
                    for (const [selector, originalText] of Object.entries(elementsToTranslate)) {
                        const el = document.querySelector(selector);
                        if (el && originalText && translationCache.has(originalText)) {
                            el.textContent = translationCache.get(originalText);
                        }
                    }
                }
            },
            renderDetailsBox(data) {
                const detailsBox = document.getElementById('details-box');
                if (!detailsBox) return;
                
                const studiosHTML = data.studios.map(s => 
                    `<a href="#" class="studio-link accent-primary-text hover:underline" data-action="open-studio" data-studio-id="${s.mal_id}" data-studio-name="${s.name}">${s.name}</a>`
                ).join(', ') || 'نامشخص';

                detailsBox.innerHTML = `
                    <h3 class="font-bold text-lg mb-3">جزئیات</h3>
                    <p class="mb-2"><strong>نوع:</strong> <span id="type-value">${data.type || 'نامشخص'}</span></p>
                    <p class="mb-2"><strong>منبع اقتباس:</strong> <span id="source-value">${data.source || 'نامشخص'}</span></p>
                    <p class="mb-2"><strong>وضعیت:</strong> <span id="status-value">${data.status || 'نامشخص'}</span></p>
                    <p class="mb-2"><strong>قسمت‌ها:</strong> ${data.episodes || 'N/A'}</p>
                    <p class="mb-2"><strong>رده سنی:</strong> <span id="rating-value">${data.rating || 'نامشخص'}</span></p>
                    <p class="mb-2"><strong>استودیو:</strong> ${studiosHTML}</p>
                    <p><strong>پخش:</strong> ${data.aired.from ? new Date(data.aired.from).toLocaleDateString('fa-IR') : 'نامشخص'}</p>
                `;
                
                document.getElementById('type-value').textContent = offlineTranslator.translate(data.type);
                document.getElementById('status-value').textContent = offlineTranslator.translate(data.status);
            },
            async renderLatestEpisode(animeId) {
                const section = document.getElementById('latest-episode-section');
                if (!section) return;
                try {
                    const result = await APIManager.fetchJikan(`anime/${animeId}/episodes`);
                    const lastEpisode = result.data?.pop();
                    if (lastEpisode) {
                        section.innerHTML = `
                            <div class="bg-accent-primary/10 border border-accent-primary/30 p-4 rounded-lg">
                                <h4 class="font-bold text-lg mb-2 accent-primary-text">آخرین قسمت پخش شده</h4>
                                <p class="text-sm"><strong>قسمت ${lastEpisode.mal_id}:</strong> ${lastEpisode.title}</p>
                                <p class="text-xs text-secondary mt-1">تاریخ پخش: ${new Date(lastEpisode.aired).toLocaleDateString('fa-IR')}</p>
                            </div>
                        `;
                    }
                } catch (error) { console.error("Failed to fetch latest episode:", error); }
            },
            renderSubtitlesSection(data) {
                const section = document.getElementById('subtitles-section');
                if (!section || !data.aired?.from) return;

                const airDate = new Date(data.aired.from);
                if (airDate.getFullYear() >= 2025) {
                    section.innerHTML = `
                        <h3 class="font-bold text-xl mb-4">زیرنویس</h3>
                        <div class="bg-tertiary p-4 rounded-lg">
                            <p class="text-secondary text-sm mb-4">اگر بدنبال زیرنویس انیمه ها هستید به کانال تلگرام من سر بزنید.</p>
                            <button id="telegram-modal-btn" class="w-full text-center accent-primary-bg text-white font-bold py-3 px-6 rounded-lg hover:opacity-90 transition-opacity">ورود به کانال تلگرام</button>
                        </div>
                    `;
                } else {
                     const searchUrl = `https://alsubs.site/?s=${encodeURIComponent(data.title)}`;
                     section.innerHTML = `
                        <h3 class="font-bold text-xl mb-4">زیرنویس</h3>
                        <div class="bg-tertiary p-4 rounded-lg">
                            <p class="text-secondary text-sm mb-4">برای دانلود زیرنویس انیمه ها به وب سایت زیر سر بزنید.</p>
                            <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" class="block w-full text-center accent-primary-bg text-white font-bold py-3 px-6 rounded-lg hover:opacity-90 transition-opacity">ورود به وب سایت alsubs</a>
                        </div>
                    `;
                }
            },
            renderRelations(relations) {
                const section = document.getElementById('relations-section');
                if (!section || !relations || relations.length === 0) return;

                const relationsHTML = relations.map(rel => {
                    return rel.entry.map(entry => `
                        <div class="result-card bg-tertiary p-3 rounded-lg flex items-center justify-between gap-4 cursor-pointer hover:bg-secondary/50 transition-colors" data-id="${entry.mal_id}">
                            <div>
                                <p class="font-bold text-sm">${entry.name}</p>
                                <p class="text-xs text-secondary">${rel.relation}</p>
                            </div>
                            <span class="text-lg">&larr;</span>
                        </div>
                    `).join('');
                }).join('');

                if (relationsHTML) {
                    section.innerHTML = `
                        <h3 class="font-bold text-xl mb-4">انیمه‌های مرتبط</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            ${relationsHTML}
                        </div>
                    `;
                }
            },
            async renderVideos(animeId, mainTrailer) {
                const section = document.getElementById('videos-section');
                if (!section) return;
                section.innerHTML = `<h3 class="font-bold text-xl mb-4">ویدیوها</h3><div class="loader mx-auto"></div>`;
                try {
                    const result = await APIManager.fetchJikan(`anime/${animeId}/videos`);
                    const promos = result.data?.promo || [];
                    let initialVideo = mainTrailer?.embed_url;
                    if (!initialVideo && promos.length > 0) {
                        initialVideo = promos[0].trailer.embed_url;
                    }

                    if (!initialVideo && promos.length === 0) {
                        section.innerHTML = '';
                        return;
                    }
                    
                    if (initialVideo) {
                        const url = new URL(initialVideo);
                        url.searchParams.set('autoplay', '0');
                        initialVideo = url.toString();
                    }

                    section.innerHTML = `
                        <h3 class="font-bold text-xl mb-4">ویدیوها</h3>
                        <div class="aspect-w-16 aspect-h-9 rounded-lg overflow-hidden shadow-lg border border-color mb-4">
                            <iframe id="video-player" class="w-full h-full" src="${initialVideo || ''}" frameborder="0" allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                        <div id="video-thumbnail-container" class="video-thumbnail-list"></div>
                    `;

                    const thumbnailContainer = document.getElementById('video-thumbnail-container');
                    if (mainTrailer?.youtube_id) {
                        const thumb = this.createVideoThumbnail(mainTrailer.embed_url, mainTrailer.images.medium_image_url, 'تریلر رسمی', initialVideo);
                        thumbnailContainer.appendChild(thumb);
                    }
                    promos.forEach(promo => {
                        const thumb = this.createVideoThumbnail(promo.trailer.embed_url, promo.trailer.images.medium_image_url, promo.title, initialVideo);
                        thumbnailContainer.appendChild(thumb);
                    });

                } catch (error) {
                    console.error("Failed to fetch videos:", error);
                    section.innerHTML = '<p class="text-secondary">ویدیویی برای نمایش یافت نشد.</p>';
                }
            },
            createVideoThumbnail(embedUrl, imageUrl, title, initialVideo) {
                const url = new URL(embedUrl);
                url.searchParams.set('autoplay', '0');
                const nonAutoplayUrl = url.toString();

                const thumbWrapper = document.createElement('div');
                thumbWrapper.className = `video-thumbnail flex-shrink-0 w-40 rounded-lg overflow-hidden ${nonAutoplayUrl === initialVideo ? 'active' : ''}`;
                thumbWrapper.innerHTML = `<img src="${imageUrl}" alt="${title}" class="w-full h-full object-cover">`;
                thumbWrapper.addEventListener('click', () => {
                    document.getElementById('video-player').src = nonAutoplayUrl;
                    document.querySelectorAll('.video-thumbnail').forEach(t => t.classList.remove('active'));
                    thumbWrapper.classList.add('active');
                });
                return thumbWrapper;
            },
            async renderCharacters(animeId) {
                const charactersSection = document.getElementById('characters-section');
                if (!charactersSection) return;
                try {
                    const result = await APIManager.fetchJikan(`anime/${animeId}/characters`);
                    if (currentAnimeData) {
                        currentAnimeData.fullCharacterList = result.data;
                    }
                    const mainCharacters = result.data.filter(c => c.role === 'Main').slice(0, 6);
                    if (mainCharacters.length === 0) {
                        charactersSection.innerHTML = ''; return;
                    }
                    charactersSection.innerHTML = `
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="font-bold text-xl">شخصیت‌های اصلی</h3>
                            <button id="show-all-chars-btn" class="text-sm accent-primary-text hover:underline font-semibold">نمایش همه</button>
                        </div>
                        <div id="character-cards-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                            ${mainCharacters.map(this.createCharacterCard).join('')}
                        </div>`;
                } catch (error) { charactersSection.innerHTML = ''; }
            },
            createCharacterCard(characterData) {
                const character = characterData.character;
                return `
                    <div class="bg-tertiary border border-color rounded-lg p-3 flex items-center gap-4 hover:border-accent-primary transition-colors">
                        <img src="${character.images?.webp?.image_url || ''}" onerror="this.src='https://placehold.co/64x64/1A2233/939CB0?text=X'" class="w-16 h-16 rounded-full object-cover">
                        <div class="flex-grow">
                            <h4 class="font-bold">${character.name}</h4>
                            <p class="text-sm text-secondary">${characterData.role}</p>
                        </div>
                        <button data-action="chat" data-character-name="${character.name}" class="gemini-button text-white text-xs font-bold py-2 px-3 rounded-full" disabled>✨ چت</button>
                    </div>
                `;
            },
            async renderRecommendations(animeId) {
                const recSection = document.getElementById('recommendations-section');
                if (!recSection) return;
                try {
                    const result = await APIManager.fetchJikan(`anime/${animeId}/recommendations`);
                    const recommendations = result.data.slice(0, 6);
                    if(recommendations.length === 0) return;
                    recSection.innerHTML = `
                        <h3 class="font-bold text-xl mb-4">انیمه‌های پیشنهادی</h3>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            ${recommendations.map(rec => `
                                <div class="result-card bg-tertiary p-2 rounded-lg text-center cursor-pointer group" data-id="${rec.entry.mal_id}">
                                    <img src="${rec.entry.images?.webp?.large_image_url || ''}" onerror="this.src='https://placehold.co/150x210/1A2233/939CB0?text=X'" class="w-full h-auto rounded-md mb-2">
                                    <p class="text-xs font-bold truncate group-hover:accent-primary-text transition-colors">${rec.entry.title}</p>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } catch (error) { console.error("Failed to fetch recommendations:", error); }
            },
            populateStudioModal(modal, studioName, animeData) {
                const modalContentHTML = `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <div class="flex items-center gap-4">
                            <h3 class="text-2xl font-bold">${studioName}</h3>
                            <button id="analyze-studio-btn" class="gemini-button text-white text-sm font-bold py-2 px-4 rounded-full">✨ تحلیل استودیو</button>
                        </div>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-6 overflow-y-auto max-h-[80vh]">
                        <div id="studio-analysis-container" class="mb-6"></div>
                        <div>
                            <h4 class="font-bold text-xl mb-4">آثار برجسته</h4>
                            <div id="studio-works-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                                ${animeData.map(anime => `
                                    <div class="result-card bg-tertiary p-2 rounded-lg text-center cursor-pointer group" data-id="${anime.mal_id}">
                                        <img src="${anime.images?.webp?.large_image_url || 'https://placehold.co/150x210/1A2233/939CB0?text=X'}" onerror="this.src='https://placehold.co/150x210/1A2233/939CB0?text=X'" class="w-full h-auto rounded-md mb-2">
                                        <p class="text-xs font-bold truncate group-hover:accent-primary-text transition-colors">${anime.title}</p>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
                modal.innerHTML = modalContentHTML;
                const modalWrapper = modal.parentElement;
                if (modalWrapper) {
                    modalWrapper.studioName = studioName; 
                    modalWrapper.studioData = animeData;
                }
                App.updateAiFeatureVisibility();
            }
        };

        const App = {
            init() {
                this.loadApiKey();
                this.updateAiFeatureVisibility();
                this.setupEventListeners();
                this.applySavedTheme();
                this.initSeason();
                UIManager.showMessage('برای شروع، نام یک انیمه را جستجو کنید یا از منو انتخاب کنید.');
            },
            loadApiKey() {
                geminiApiKey = localStorage.getItem('geminiApiKey');
            },
            updateAiFeatureVisibility() {
                const isAiEnabled = !!geminiApiKey;
                document.querySelectorAll('.gemini-button, [data-action="chat"], #find-similar-btn, #analyze-studio-btn').forEach(btn => {
                    btn.disabled = !isAiEnabled;
                });

                if (isAiEnabled) {
                    DOMElements.apiKeyBtnText.textContent = "API تنظیم شده";
                    DOMElements.apiKeyBtn.classList.add('accent-primary-text');
                } else {
                    DOMElements.apiKeyBtnText.textContent = "تنظیم API";
                    DOMElements.apiKeyBtn.classList.remove('accent-primary-text');
                }
            },
            navigateToDetails(id, isNewChain = false) {
                if (isNewChain) navigationHistory = [];
                if (navigationHistory[navigationHistory.length - 1] !== id) navigationHistory.push(id);
                UIManager.showDetailsPage(id);
            },
            navigateBack() {
                navigationHistory.pop();
                if (navigationHistory.length > 0) {
                    UIManager.showDetailsPage(navigationHistory[navigationHistory.length - 1]);
                } else {
                    UIManager.showMainPage();
                }
            },
            setupEventListeners() {
                DOMElements.searchForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSearch(DOMElements.searchInput.value.trim());
                });
                DOMElements.searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchDebounceTimeout);
                    const query = e.target.value.trim();
                    if (query.length > 2) {
                        // START: Increased debounce timeout to reduce API calls
                        searchDebounceTimeout = setTimeout(() => this.handleSearch(query), 600);
                        // END: Increased debounce timeout
                    } else if (query.length === 0) {
                        DOMElements.resultsContainer.innerHTML = '';
                        DOMElements.smartResultsTitle.classList.add('hidden');
                        UIManager.showMessage('برای شروع، نام یک انیمه را جستجو کنید.');
                    }
                });
                DOMElements.themeSwitch.addEventListener('change', () => {
                    const newTheme = DOMElements.themeSwitch.checked ? 'light' : 'dark';
                    localStorage.setItem('theme', newTheme);
                    this.applyTheme(newTheme);
                });

                // Master Click Handler using Event Delegation
                document.body.addEventListener('click', (e) => {
                    const target = e.target;
                    
                    const cardTarget = target.closest('.result-card[data-id]');
                    if (cardTarget) {
                        this.navigateToDetails(cardTarget.dataset.id, true);
                        return;
                    }
                    
                    const buttonTarget = target.closest('button');
                    if (buttonTarget) {
                        const action = buttonTarget.dataset.action;
                        const tab = buttonTarget.dataset.tab;

                        if (action === 'chat' && !buttonTarget.disabled) {
                            this.handleCharacterChat(buttonTarget.dataset.characterName);
                            return;
                        }
                        if (tab) {
                            this.handleTabClick(buttonTarget);
                            return;
                        }

                        if (!buttonTarget.disabled) {
                            switch (buttonTarget.id) {
                                case 'smart-suggest-btn': this.handleSmartSuggest(); break;
                                case 'api-key-btn': this.handleSetApiKey(); break;
                                case 'menu-toggle-btn': DOMElements.mainMenu.classList.toggle('hidden'); break;
                                case 'prev-season-btn': this.changeSeason(-1); break;
                                case 'next-season-btn': this.changeSeason(1); break;
                                case 'back-button': this.navigateBack(); break;
                                case 'smart-analysis-btn': this.handleSmartAnalysis(); break;
                                case 'find-similar-btn': this.handleFindSimilar(); break;
                                case 'show-all-chars-btn':
                                    if (currentAnimeData?.fullCharacterList) {
                                        this.handleShowAllCharacters(currentAnimeData.fullCharacterList);
                                    }
                                    break;
                                case 'telegram-modal-btn': this.handleTelegramModal(); break;
                                case 'analyze-studio-btn':
                                    const modal = document.getElementById('studio-modal');
                                    if (modal && modal.studioName && modal.studioData) {
                                        this.handleStudioAnalysis(modal.studioName, modal.studioData);
                                    }
                                    break;
                                case 'show-more-btn':
                                    currentPage++;
                                    this.loadList(currentListType, currentPage, true);
                                    break;
                            }
                        }
                    }

                    const linkTarget = target.closest('a[data-action="open-studio"]');
                    if (linkTarget) {
                        e.preventDefault();
                        this.handleStudioClick(linkTarget.dataset.studioId, linkTarget.dataset.studioName);
                        return;
                    }
                    
                    const closeModalButton = target.closest('.close-modal-btn');
                    if (closeModalButton) {
                        const modal = closeModalButton.closest('.fixed.inset-0');
                        if (modal) ModalManager.close(modal.id);
                        return;
                    }

                    if (!DOMElements.mainMenu.classList.contains('hidden') && !target.closest('#main-menu') && !target.closest('#menu-toggle-btn')) {
                        DOMElements.mainMenu.classList.add('hidden');
                    }
                });
            },
            async handleSearch(query) {
                if (!query) return;
                const isPersian = /[\u0600-\u06FF]/.test(query);
                if (isPersian) {
                    await this.handlePersianSearch(query);
                } else {
                    await this.handleStandardSearch(query);
                }
            },
            async handleStandardSearch(query) {
                latestSearchQuery = query;
                DOMElements.resultsContainer.innerHTML = '';
                DOMElements.smartResultsTitle.classList.add('hidden');
                UIManager.showMessage('');
                UIManager.showLoader(true);
                try {
                    const result = await APIManager.fetchJikan(`anime?q=${encodeURIComponent(query)}&limit=24`);
                    if (latestSearchQuery === query) {
                        UIManager.displayResults(result.data);
                    }
                } catch (error) { UIManager.showMessage(error.message, true);
                } finally { UIManager.showLoader(false); }
            },
            async handlePersianSearch(persianQuery) {
                latestSearchQuery = persianQuery;
                DOMElements.resultsContainer.innerHTML = '';
                DOMElements.smartResultsTitle.classList.add('hidden');
                UIManager.showMessage('');
                UIManager.showLoader(true);
                try {
                    const englishTitle = await APIManager.translateToEnglish(persianQuery);
                    const result = await APIManager.fetchJikan(`anime?q=${encodeURIComponent(englishTitle)}&limit=24`);
                    if (latestSearchQuery === persianQuery) {
                        UIManager.displayResults(result.data, `نتایج برای «${persianQuery}»`);
                    }
                } catch (error) {
                    UIManager.showMessage(error.message, true);
                } finally {
                    UIManager.showLoader(false);
                }
            },
            handleTabClick(tab) {
                const tabName = tab.dataset.tab;
                currentListType = tabName;
                currentPage = 1;

                document.querySelectorAll('.tab-button').forEach(t => {
                    t.classList.remove('accent-primary-text');
                    t.classList.add('text-secondary');
                });
                tab.classList.add('accent-primary-text');
                tab.classList.remove('text-secondary');
                
                DOMElements.searchPage.classList.toggle('hidden', tabName !== 'search');
                DOMElements.listPage.classList.toggle('hidden', tabName === 'search');
                
                DOMElements.resultsContainer.innerHTML = '';
                DOMElements.smartResultsTitle.classList.add('hidden');
                DOMElements.showMoreContainer.innerHTML = '';
                
                if (tabName === 'search') {
                     UIManager.showMessage('برای شروع، نام یک انیمه را جستجو کنید یا از منو انتخاب کنید.');
                } else {
                    UIManager.showMessage('');
                    if (tabName === 'top') {
                        DOMElements.seasonNav.classList.add('hidden');
                        DOMElements.listTitle.textContent = 'برترین‌های MAL';
                        this.loadList(tabName, currentPage);
                    } else if (tabName === 'airing') {
                        DOMElements.seasonNav.classList.remove('hidden');
                        DOMElements.listTitle.textContent = 'انیمه‌های در حال پخش';
                        this.loadList(tabName, currentPage);
                    }
                }
                DOMElements.mainMenu.classList.add('hidden');
            },
            async loadList(type, page, append = false) {
                UIManager.showLoader(true);
                if (!append) {
                    DOMElements.resultsContainer.innerHTML = '';
                }
                DOMElements.showMoreContainer.innerHTML = '';

                try {
                    let endpoint = '';
                    if (type === 'top') {
                        endpoint = `top/anime?page=${page}`;
                    } else if (type === 'airing') {
                        const { year, season } = currentSeasonState;
                        DOMElements.seasonDisplay.textContent = `${offlineTranslator.translate(season)} ${year}`;
                        endpoint = `seasons/${year}/${season}?page=${page}`;
                    }
                    
                    if(!endpoint) return;

                    const result = await APIManager.fetchJikan(endpoint);
                    UIManager.displayResults(result.data, null, { append, showMoreCallback: result.pagination.has_next_page });

                } catch (error) {
                    UIManager.showMessage(error.message, true);
                } finally {
                    UIManager.showLoader(false);
                }
            },
            initSeason() {
                const date = new Date();
                const year = date.getFullYear();
                const month = date.getMonth();
                let season = 'winter'; // Dec, Jan, Feb
                if (month >= 2 && month <= 4) season = 'spring'; // Mar, Apr, May
                if (month >= 5 && month <= 7) season = 'summer'; // Jun, Jul, Aug
                if (month >= 8 && month <= 10) season = 'fall'; // Sep, Oct, Nov
                currentSeasonState = { year, season };
            },
            changeSeason(direction) {
                const seasons = ['winter', 'spring', 'summer', 'fall'];
                let { year, season } = currentSeasonState;
                let seasonIndex = seasons.indexOf(season);
                seasonIndex += direction;
                if (seasonIndex > 3) { seasonIndex = 0; year++; } 
                else if (seasonIndex < 0) { seasonIndex = 3; year--; }
                currentSeasonState = { year, season: seasons[seasonIndex] };
                currentPage = 1;
                this.loadList('airing', currentPage);
            },
            applyTheme(theme) {
                document.body.classList.toggle('light', theme === 'light');
                DOMElements.themeSwitch.checked = theme === 'light';
            },
            applySavedTheme() {
                this.applyTheme(localStorage.getItem('theme') || 'dark');
            },

            handleSetApiKey() {
                const modalContent = `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">🔑 تنظیم کلید API جمنای</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-6 text-sm text-secondary leading-relaxed">
                        <p class="mb-4">برای استفاده از امکانات هوشمند (ترجمه و تحلیل)، به کلید API از Google Gemini نیاز دارید.</p>
                        <h4 class="font-bold text-primary mb-2">چگونه کلید API دریافت کنیم؟</h4>
                        <ol class="list-decimal list-inside mb-4 space-y-2">
                            <li>به سایت <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="accent-primary-text hover:underline">Google AI Studio</a> بروید.</li>
                            <li>با حساب گوگل خود وارد شوید و روی "Create API key" کلیک کنید.</li>
                            <li>کلید ساخته شده را کپی و در کادر زیر قرار دهید.</li>
                        </ol>
                        <p class="mb-4 text-xs">این کلید فقط در مرورگر شما ذخیره می‌شود.</p>
                        <input id="api-key-input" type="password" class="bg-tertiary w-full p-3 rounded-lg border-2 border-color focus:border-accent-primary focus:outline-none" placeholder="کلید API خود را اینجا وارد کنید..." value="${geminiApiKey || ''}">
                        <p id="api-key-error" class="text-red-400 text-xs mt-2 h-4"></p>
                        <button id="api-key-save-btn" class="w-full mt-2 accent-primary-bg text-white font-bold py-3 px-6 rounded-lg hover:opacity-90 transition-opacity">ذخیره و فعال‌سازی</button>
                    </div>
                `;
                const modal = ModalManager.create('api-key-modal', modalContent, {maxWidth: 'max-w-2xl'});
                const input = modal.querySelector('#api-key-input');
                const saveBtn = modal.querySelector('#api-key-save-btn');
                const errorP = modal.querySelector('#api-key-error');

                saveBtn.addEventListener('click', async () => {
                    const key = input.value.trim();
                    if (!key) {
                        localStorage.removeItem('geminiApiKey');
                        ModalManager.showNotification('کلید API حذف شد.', 'info');
                        setTimeout(() => location.reload(), 2000);
                        return;
                    }
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'در حال بررسی...';
                    errorP.textContent = '';
                    if (await APIManager.validateApiKey(key)) {
                        localStorage.setItem('geminiApiKey', key);
                        ModalManager.showNotification('کلید API با موفقیت ذخیره شد.', 'success');
                        setTimeout(() => location.reload(), 2000);
                    } else {
                        errorP.textContent = 'کلید API وارد شده نامعتبر است.';
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'ذخیره و فعال‌سازی';
                    }
                });
            },
            handleSmartSuggest() {
                const modalContent = `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">✨ پیشنهاد مفهومی</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-6">
                        <p class="text-secondary mb-4">توضیح دهید دنبال چه نوع انیمه‌ای هستید. مثلا: "یک انیمه ماجراجویی با داستانی حماسی"</p>
                        <textarea id="smart-suggest-input" class="bg-tertiary w-full p-3 rounded-lg border-2 border-color focus:border-accent-primary focus:outline-none" rows="4"></textarea>
                        <button id="smart-suggest-submit" class="w-full mt-4 accent-primary-bg text-white font-bold py-3 px-6 rounded-lg">یافتن انیمه‌ها</button>
                    </div>
                `;
                const modal = ModalManager.create('smart-suggest-modal', modalContent);
                
                modal.querySelector('#smart-suggest-submit').addEventListener('click', async () => {
                    const userInput = modal.querySelector('#smart-suggest-input').value.trim();
                    if (!userInput) return;
                    ModalManager.closeAll();
                    UIManager.showMessage('');
                    UIManager.showLoader(true);
                    try {
                        const prompt = `Based on the user's request in Persian: '${userInput}', recommend exactly 8 anime. Return a JSON object with a key "recommendations", an array of objects with keys "title" (English) and "mal_id" (the MyAnimeList ID as a number). Example: {"recommendations": [{"title": "Fullmetal Alchemist: Brotherhood", "mal_id": 5114}]}. Provide ONLY the JSON.`;
                        const response = await APIManager.callGemini(prompt, true);
                        if (!response.recommendations?.length) {
                            throw new Error("هوش مصنوعی نتوانست انیمه‌ای مطابق با درخواست شما پیدا کند.");
                        }

                        const animeDataResults = [];
                        for (const rec of response.recommendations) {
                            try {
                                const res = await APIManager.fetchJikan(`anime/${rec.mal_id}`);
                                if (res.data) {
                                    animeDataResults.push({ node: res.data });
                                }
                            } catch (error) {
                                console.warn(`Could not fetch details for "${rec.title}":`, error);
                            }
                        }
                        
                        UIManager.displayResults(animeDataResults, `✨ پیشنهادهای هوشمند برای: "${userInput}"`);
                    } catch (error) {
                        UIManager.showMessage(`خطا: ${error.message}`, true);
                    } finally {
                        UIManager.showLoader(false);
                    }
                });
            },
            handleShowAllCharacters(allCharacters) {
                const modalContent = `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">تمام شخصیت‌ها</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div id="all-chars-list" class="p-4 overflow-y-auto space-y-3 max-h-[70vh]">
                        ${allCharacters.map(UIManager.createCharacterCard).join('')}
                    </div>
                `;
                ModalManager.create('all-characters-modal', modalContent, { maxWidth: 'max-w-3xl' });
                this.updateAiFeatureVisibility(); 
            },
            handleTelegramModal() {
                const modalContent = `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">📢 توجه</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-6 text-center">
                        <p class="text-secondary mb-6">اگر زیرنویسی از انیمه مورد نظرتان پیدا نکردید از طريق گروه چت اعلام کنید و در کوتاه ترین زمان ممکن قرار خواهد گرفت.</p>
                        <a href="https://t.me/anime_sub_Persian" target="_blank" rel="noopener noreferrer" class="block w-full text-center accent-primary-bg text-white font-bold py-3 px-6 rounded-lg hover:opacity-90 transition-opacity">ورود به کانال تلگرام</a>
                    </div>
                `;
                ModalManager.create('telegram-info-modal', modalContent);
            },
            async handleCharacterChat(characterName) {
                if (!currentAnimeData) return;
                const animeTitle = currentAnimeData.title_english || currentAnimeData.title;
                let chatHistory = [];
                const modal = ModalManager.create('character-chat-modal', `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">✨ گفتگو با ${characterName}</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div id="chat-messages" class="p-4 flex-grow overflow-y-auto h-96 flex flex-col gap-4">
                         <div class="chat-bubble chat-bubble-bot">سلام! من ${characterName} هستم. چه سوالی داری؟</div>
                    </div>
                    <div class="p-4 border-t border-color">
                        <form id="chat-form" class="flex gap-2">
                            <input id="chat-input" type="text" class="bg-tertiary w-full p-3 rounded-lg border-2 border-color focus:border-accent-primary focus:outline-none" placeholder="پیام خود را بنویسید...">
                            <button type="submit" class="accent-primary-bg text-white font-bold py-3 px-5 rounded-lg">ارسال</button>
                        </form>
                    </div>`, {maxWidth: 'max-w-2xl'});
                
                modal.querySelector('#chat-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const chatInput = modal.querySelector('#chat-input');
                    const submitButton = e.target.querySelector('button');
                    const chatMessages = modal.querySelector('#chat-messages');
                    const userInput = chatInput.value.trim();
                    if (!userInput) return;

                    chatMessages.innerHTML += `<div class="chat-bubble chat-bubble-user">${userInput}</div>`;
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    chatInput.value = '';
                    submitButton.disabled = true;
                    submitButton.textContent = '...';

                    chatHistory.push({ role: "user", parts: [{ text: userInput }] });
                    try {
                        const prompt = `You are roleplaying as ${characterName} from ${animeTitle}. Maintain this persona. Respond to the latest user message in character. IMPORTANT: Respond ONLY in Persian.\n\nConversation History:\n${JSON.stringify(chatHistory)}\n\nUser: "${userInput}"\n${characterName}:`;
                        const botResponse = await APIManager.callGemini(prompt);
                        chatHistory.push({ role: "model", parts: [{ text: botResponse }] });
                        chatMessages.innerHTML += `<div class="chat-bubble chat-bubble-bot">${botResponse}</div>`;
                    } catch (error) {
                        chatMessages.innerHTML += `<div class="chat-bubble chat-bubble-bot text-red-400">متاسفانه مشکلی پیش آمد: ${error.message}</div>`;
                    } finally {
                        submitButton.disabled = false;
                        submitButton.textContent = 'ارسال';
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                });
            },
            async handleSmartAnalysis() {
                if (!currentAnimeData) return;
                const modal = ModalManager.create('smart-analysis-modal', `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">✨ تحلیل هوشمند</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-8 text-center"><div class="loader mx-auto"></div><p class="mt-4 text-secondary">در حال تحلیل با هوش مصنوعی...</p></div>`, {maxWidth: 'max-w-3xl'});

                try {
                    const { title, synopsis, genres } = currentAnimeData;
                    const genreNames = genres.map(g => g.name).join(', ');
                    const prompt = `As an anime critic, provide a comprehensive analysis for '${title}' (genres: ${genreNames}, synopsis: ${synopsis}). Respond in Persian. Return a JSON object with keys: "analysis" (a brief summary), "strengths" (array of strings), "weaknesses" (array of strings), "audience" (a paragraph describing the ideal audience). Provide ONLY the JSON.`;
                    const analysis = await APIManager.callGemini(prompt, true);
                    modal.innerHTML = `
                        <div class="p-4 border-b border-color flex justify-between items-center">
                            <h3 class="text-xl font-bold">✨ تحلیل هوشمند: ${title}</h3>
                            <button class="close-modal-btn p-2 text-2xl">&times;</button>
                        </div>
                        <div class="p-6 overflow-y-auto max-h-[70vh] space-y-6">
                            <div>
                                <h4 class="font-bold text-lg accent-primary-text mb-2">تحلیل کلی</h4>
                                <p class="text-secondary leading-relaxed">${analysis.analysis}</p>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <h4 class="font-bold text-lg text-green-400 mb-3">🟢 نقاط قوت احتمالی</h4>
                                    <ul class="list-disc list-inside text-secondary space-y-2">${analysis.strengths.map(s => `<li>${s}</li>`).join('')}</ul>
                                </div>
                                <div>
                                    <h4 class="font-bold text-lg text-red-400 mb-3">🔴 نقاط ضعف احتمالی</h4>
                                    <ul class="list-disc list-inside text-secondary space-y-2">${analysis.weaknesses.map(w => `<li>${w}</li>`).join('')}</ul>
                                </div>
                            </div>
                             <div>
                                <h4 class="font-bold text-lg accent-secondary-text mb-2">برای چه کسانی مناسب است؟</h4>
                                <p class="text-secondary leading-relaxed">${analysis.audience}</p>
                            </div>
                        </div>`;
                } catch (error) {
                    modal.querySelector('.p-8').innerHTML = `<p class="p-4 text-center text-red-400">خطا در تحلیل: ${error.message}</p>`;
                }
            },
            async handleFindSimilar() {
                if (!currentAnimeData) return;
                const modal = ModalManager.create('similar-anime-modal', `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">✨ یافتن انیمه‌های مشابه</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-8 text-center"><div class="loader mx-auto"></div><p class="mt-4 text-secondary">در حال یافتن پیشنهادها...</p></div>`, {maxWidth: 'max-w-4xl'});

                try {
                    const { title, genres, synopsis } = currentAnimeData;
                    const prompt = `Based on the anime "${title}" (genres: ${genres.map(g=>g.name).join(', ')}, synopsis: ${synopsis}), recommend 4 similar anime. For each, provide a brief reason. The reason MUST be in Persian. Return a JSON object with a key "recommendations", an array of objects with keys "title" (English) and "reason" (the reason in Persian). Example: {"recommendations": [{"title": "Attack on Titan", "reason": "فضایی تاریک و نبردهای استراتژیک دارد."}]}`;
                    const response = await APIManager.callGemini(prompt, true);
                    if (!response.recommendations?.length) throw new Error("هوش مصنوعی نتوانست پیشنهاد مشابهی پیدا کند.");

                    let resultsHTML = '';
                    for (const rec of response.recommendations) {
                        try {
                            const res = await APIManager.fetchJikan(`anime?q=${encodeURIComponent(rec.title)}&limit=1`);
                            const animeInfo = res.data?.[0];
                            if (animeInfo) {
                                resultsHTML += `
                                    <div class="result-card bg-tertiary border border-color rounded-lg p-4 flex items-start gap-4 cursor-pointer hover:bg-secondary transition-colors" data-id="${animeInfo.mal_id}">
                                        <img src="${animeInfo.images.webp.image_url}" class="w-20 h-auto rounded-md flex-shrink-0">
                                        <div class="flex-grow">
                                            <h4 class="font-bold text-lg">${animeInfo.title}</h4>
                                            <p class="text-sm text-secondary mt-1">${rec.reason}</p>
                                        </div>
                                    </div>`;
                            }
                        } catch(e){ console.warn(`Could not fetch data for similar anime: ${rec.title}`, e); }
                    }
                    modal.innerHTML = `
                        <div class="p-4 border-b border-color flex justify-between items-center">
                            <h3 class="text-xl font-bold">✨ پیشنهادهای مشابه برای ${title}</h3>
                            <button class="close-modal-btn p-2 text-2xl">&times;</button>
                        </div>
                        <div id="similar-results-container" class="p-4 grid grid-cols-1 md:grid-cols-2 gap-4 overflow-y-auto max-h-[70vh]">${resultsHTML}</div>`;
                } catch (error) {
                     modal.querySelector('.p-8').innerHTML = `<p class="p-4 text-center text-red-400">خطا: ${error.message}</p>`;
                }
            },
            async handleStudioClick(studioId, studioName) {
                const modal = ModalManager.create('studio-modal', `
                    <div class="p-4 border-b border-color flex justify-between items-center">
                        <h3 class="text-xl font-bold">اطلاعات استودیو</h3>
                        <button class="close-modal-btn p-2 text-2xl">&times;</button>
                    </div>
                    <div class="p-8 text-center"><div class="loader mx-auto"></div><p class="mt-4 text-secondary">در حال دریافت آثار استودیو ${studioName}...</p></div>
                `, { maxWidth: 'max-w-4xl' });

                try {
                    const result = await APIManager.fetchJikan(`anime?producers=${studioId}&limit=24`);
                    UIManager.populateStudioModal(modal, studioName, result.data);
                } catch (error) {
                    ModalManager.close('studio-modal');
                    UIManager.showMessage(`خطا در دریافت اطلاعات استودیو: ${error.message}`, true);
                }
            },
            async handleStudioAnalysis(studioName, animeData) {
                const analysisContainer = document.getElementById('studio-analysis-container');
                if (!analysisContainer) return;

                analysisContainer.innerHTML = `<div class="p-4 text-center"><div class="loader mx-auto"></div><p class="mt-4 text-secondary">در حال تحلیل استودیو ${studioName}...</p></div>`;
                const analyzeBtn = document.getElementById('analyze-studio-btn');
                if(analyzeBtn) analyzeBtn.disabled = true;

                try {
                    const animeTitles = animeData.slice(0, 15).map(a => a.title).join(', ');
                    const prompt = `Provide a brief analysis of the animation studio "${studioName}". Comment on their typical genres, animation style, and reputation based on these works: ${animeTitles}. Your entire response, including the JSON values, MUST be in Persian. Ensure all genre names in the "common_genres" array are the Persian translations. Return a JSON object with keys: "analysis" (a paragraph in Persian), "common_genres" (array of Persian genre names), and "key_strengths" (array of strings in Persian). Provide ONLY the JSON.`;
                    
                    const analysis = await APIManager.callGemini(prompt, true);
                    
                    const translatedGenres = (analysis.common_genres || []).map(g => offlineTranslator.translate(g));

                    analysisContainer.innerHTML = `
                        <h4 class="font-bold text-xl mb-3 accent-primary-text">تحلیل هوشمند استودیو</h4>
                        <p class="text-secondary leading-relaxed mb-4">${analysis.analysis || ''}</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <h5 class="font-bold text-lg mb-2">ژانرهای متداول</h5>
                                <div class="flex flex-wrap gap-2">
                                    ${translatedGenres.map(g => `<span class="bg-tertiary text-sm font-semibold px-3 py-1 rounded-full">${g}</span>`).join('')}
                                </div>
                            </div>
                            <div>
                                <h5 class="font-bold text-lg mb-2">نقاط قوت کلیدی</h5>
                                <ul class="list-disc list-inside text-secondary space-y-1">
                                    ${(analysis.key_strengths || []).map(s => `<li>${s}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                } catch (error) {
                    analysisContainer.innerHTML = `<p class="p-4 text-center text-red-400">خطا در تحلیل استودیو: ${error.message}</p>`;
                    if(analyzeBtn) analyzeBtn.disabled = false;
                }
            }
        };

        window.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
